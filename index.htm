<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colony Sim</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #282c34;
            color: #f1f1f1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            color: #61afef;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #61afef;
            border-radius: 8px;
            background-color: #21252b;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        canvas {
            background-color: #3f444f;
            display: block;
            border-bottom: 2px solid #61afef;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
        }

        #ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            background-color: #282c34;
            border-radius: 0 0 6px 6px;
        }

        #resources {
            font-size: 1.1em;
        }

        #resources span {
            margin-right: 20px;
            color: #98c379;
        }

        #resources span.stone {
            color: #e5c07b;
        }

        #build-menu button {
            font-size: 1em;
            padding: 8px 12px;
            margin-left: 10px;
            background-color: #61afef;
            color: #21252b;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        #build-menu button:hover {
            background-color: #c678dd;
        }

        #build-menu button.active {
            background-color: #98c379;
            transform: scale(1.05);
            box-shadow: 0 0 10px #98c379;
        }

        /* --- Estilos da Lista de Tarefas --- */
        .main-wrapper {
            display: flex;
            flex-direction: row;
            align-items: flex-start; /* Alinha os itens no topo */
            gap: 20px; /* Espaço entre o jogo e a lista de tarefas */
        }

        #task-list-container {
            width: 250px;
            /* A altura do canvas (600) + a altura do painel (74) - paddings e bordas */
            height: calc(30 * 20px + 74px);
            border: 2px solid #61afef;
            border-radius: 8px;
            background-color: #21252b;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            padding: 15px;
            box-sizing: border-box;
            color: #f1f1f1;
            display: flex;
            flex-direction: column;
        }

        #task-list-container h2 {
            margin-top: 0;
            color: #61afef;
            text-align: center;
            border-bottom: 1px solid #61afef;
            padding-bottom: 10px;
            flex-shrink: 0; /* Impede que o h2 encolha */
        }

        #task-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto; /* Adiciona scroll se a lista for grande */
            flex-grow: 1; /* Faz a lista ocupar o espaço restante */
        }

        #task-list li {
            background-color: #282c34;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 0.9em;
            transition: background-color 0.2s;
            cursor: default;
        }

        #task-list li.active-task {
            background-color: #98c379;
            color: #21252b;
            font-weight: bold;
        }

        .task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cancel-btn {
            background-color: #e06c75;
            color: #21252b;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-weight: bold;
            line-height: 20px;
            text-align: center;
            transition: background-color 0.2s;
        }

        .cancel-btn:hover {
            background-color: #c678dd;
        }
    </style>
</head>
<body>

    <div class="main-wrapper">
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <div id="ui-panel">
                <div id="resources">
                    <span id="wood-display">Madeira: 0</span>
                    <span id="stone-display" class="stone">Pedra: 0</span>
                </div>
                <div id="build-menu">
                    <button id="btn-cut">Cortar Árvore</button>
                    <button id="btn-mine">Minar Rocha</button>
                    <button id="btn-wall">Construir Muro</button>
                    <button id="btn-move">Mover</button>
                </div>
            </div>
        </div>
        <div id="task-list-container">
            <h2>Tarefas</h2>
            <ul id="task-list">
                <!-- Tarefas serão preenchidas via JavaScript -->
            </ul>
        </div>
    </div>

    <script>
        // --- Configuração Inicial ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 20;
        const MAP_WIDTH_TILES = 40;
        const MAP_HEIGHT_TILES = 30;

        canvas.width = MAP_WIDTH_TILES * TILE_SIZE;
        canvas.height = MAP_HEIGHT_TILES * TILE_SIZE;

        // --- Estado do Jogo ---
        let map = []; // 2D array [y][x]
        let pawn = null; // O único colono
        let tasks = []; // Array de tarefas pendentes
        let resources = {
            wood: 50,
            stone: 50
        };
        let selectedTool = null; // 'cut', 'mine', 'wall'
        let mouseTileX = 0;
        let mouseTileY = 0;
        let gameTick = 0;

        // --- Tipos de Tile ---
        const TILE_TYPES = {
            GRASS: { id: 0, color: '#2a502a' },
            TREE: { id: 1, color: '#0e3a0e' },
            ROCK: { id: 2, color: '#686868' },
            WALL: { id: 3, color: '#8b4513' },
            TASK_CUT: { color: 'rgba(255, 255, 0, 0.5)' }, // Amarelo
            TASK_MINE: { color: 'rgba(255, 165, 0, 0.5)' }, // Laranja
            TASK_BUILD: { color: 'rgba(0, 191, 255, 0.5)' }, // Azul
            TASK_MOVE: { color: 'rgba(255, 255, 255, 0.5)' } // Branco
        };

        // --- Classes Simples ---
        class Pawn {
            constructor(x, y) {
                this.x = x; // Posição em tile
                this.y = y; // Posição em tile
                this.state = 'idle'; // 'idle', 'moving', 'working'
                this.task = null; // Tarefa atual
                this.workProgress = 0;
                this.color = '#3498db'; // Azul
            }
        }

        let nextTaskId = 0;
        class Task {
            constructor(type, x, y) {
                this.id = nextTaskId++;
                this.type = type; // 'cut', 'mine', 'wall'
                this.x = x;
                this.y = y;
            }
        }

        // --- Funções de Inicialização ---
        function initializeMap() {
            map = [];
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                const row = [];
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    let type = TILE_TYPES.GRASS;
                    if (Math.random() > 0.85) {
                        type = TILE_TYPES.TREE;
                    } else if (Math.random() > 0.93) {
                        type = TILE_TYPES.ROCK;
                    }
                    row.push({ ...type }); // Clona o objeto
                }
                map.push(row);
            }
        }

        function initializePawn() {
            pawn = new Pawn(10, 10);
        }

        // --- Funções de Desenho (Renderização) ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            drawTasks();
            drawPawn();
            drawMouseHighlight();
            updateUI();
        }

        function drawMap() {
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    const tile = map[y][x];
                    // Desenha a base de grama
                    ctx.fillStyle = TILE_TYPES.GRASS.color;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                    // Desenha a entidade (árvore, pedra, etc.) por cima
                    if (tile.id === TILE_TYPES.TREE.id) {
                        drawTree(x, y);
                    } else if (tile.id === TILE_TYPES.ROCK.id) {
                        drawRock(x, y);
                    } else if (tile.id === TILE_TYPES.WALL.id) {
                        ctx.fillStyle = tile.color;
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
                    }
                }
            }
        }

        function drawTree(x, y) {
            const tileX = x * TILE_SIZE;
            const tileY = y * TILE_SIZE;
            // Tronco
            ctx.fillStyle = '#8b4513'; // Marrom
            ctx.fillRect(tileX + TILE_SIZE * 0.4, tileY + TILE_SIZE * 0.6, TILE_SIZE * 0.2, TILE_SIZE * 0.4);
            // Copa
            ctx.fillStyle = '#228B22'; // Verde floresta
            ctx.beginPath();
            ctx.arc(tileX + TILE_SIZE / 2, tileY + TILE_SIZE * 0.4, TILE_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRock(x, y) {
            const tileX = x * TILE_SIZE;
            const tileY = y * TILE_SIZE;
            ctx.fillStyle = '#808080'; // Cinza
            ctx.beginPath();
            ctx.moveTo(tileX + TILE_SIZE * 0.2, tileY + TILE_SIZE * 0.8);
            ctx.lineTo(tileX + TILE_SIZE * 0.8, tileY + TILE_SIZE * 0.8);
            ctx.lineTo(tileX + TILE_SIZE * 0.9, tileY + TILE_SIZE * 0.5);
            ctx.lineTo(tileX + TILE_SIZE * 0.5, tileY + TILE_SIZE * 0.2);
            ctx.lineTo(tileX + TILE_SIZE * 0.1, tileY + TILE_SIZE * 0.5);
            ctx.closePath();
            ctx.fill();
        }

        function drawTasks() {
            tasks.forEach(task => {
                let taskColor = 'rgba(255, 255, 255, 0.3)'; // Default
                if (task.type === 'cut') taskColor = TILE_TYPES.TASK_CUT.color;
                if (task.type === 'mine') taskColor = TILE_TYPES.TASK_MINE.color;
                if (task.type === 'wall') taskColor = TILE_TYPES.TASK_BUILD.color;
                if (task.type === 'move') taskColor = TILE_TYPES.TASK_MOVE.color;

                ctx.fillStyle = taskColor;
                ctx.fillRect(task.x * TILE_SIZE, task.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            });
        }

        function drawPawn() {
            if (!pawn) return;
            ctx.fillStyle = pawn.color;
            ctx.beginPath();
            ctx.arc(
                pawn.x * TILE_SIZE + TILE_SIZE / 2,
                pawn.y * TILE_SIZE + TILE_SIZE / 2,
                TILE_SIZE / 2.5, // Raio
                0, Math.PI * 2
            );
            ctx.fill();

            // Desenha barra de progresso se estiver trabalhando
            if (pawn.state === 'working') {
                const progress = pawn.workProgress / 100; // 100 ticks para completar
                ctx.fillStyle = '#98c379';
                ctx.fillRect(
                    pawn.x * TILE_SIZE,
                    pawn.y * TILE_SIZE - 5,
                    TILE_SIZE * progress,
                    3
                );
            }
        }

        function drawMouseHighlight() {
            if (!selectedTool) return;
            ctx.strokeStyle = '#f1f1f1';
            ctx.lineWidth = 1;
            ctx.strokeRect(mouseTileX * TILE_SIZE, mouseTileY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }

        function updateUI() {
            document.getElementById('wood-display').innerText = `Madeira: ${resources.wood}`;
            document.getElementById('stone-display').innerText = `Pedra: ${resources.stone}`;

            // Atualiza botões ativos
            document.getElementById('btn-cut').classList.toggle('active', selectedTool === 'cut');
            document.getElementById('btn-mine').classList.toggle('active', selectedTool === 'mine');
            document.getElementById('btn-wall').classList.toggle('active', selectedTool === 'wall');
            document.getElementById('btn-move').classList.toggle('active', selectedTool === 'move');

            updateTaskListUI();
        }

        function updateTaskListUI() {
            const taskListEl = document.getElementById('task-list');
            taskListEl.innerHTML = ''; // Limpa a lista antes de redesenhar

            // Helper para criar um item da lista
            const createTaskItem = (task, is_active) => {
                const li = document.createElement('li');

                const text = document.createElement('span');
                text.textContent = `${is_active ? '[ATIVA] ' : ''}${task.type} (${task.x}, ${task.y})`;

                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'X';
                cancelButton.className = 'cancel-btn';
                cancelButton.onclick = () => cancelTask(task.id, is_active);

                li.className = is_active ? 'active-task task-item' : 'task-item';
                li.appendChild(text);
                li.appendChild(cancelButton);
                return li;
            };

            // Adiciona a tarefa ativa (se houver)
            if (pawn && pawn.task) {
                taskListEl.appendChild(createTaskItem(pawn.task, true));
            }

            // Adiciona as tarefas pendentes
            tasks.forEach(task => {
                taskListEl.appendChild(createTaskItem(task, false));
            });
        }

        function cancelTask(taskId, is_active) {
            if (is_active) {
                if (pawn && pawn.task && pawn.task.id === taskId) {
                    pawn.task = null;
                    pawn.state = 'idle';
                    pawn.workProgress = 0;
                }
            } else {
                tasks = tasks.filter(t => t.id !== taskId);
            }
            draw(); // Força a atualização da UI
        }

        // --- Funções de Lógica (Atualização) ---
        function update() {
            gameTick++;
            // A IA só roda a cada N ticks para desacelerar
            if (gameTick % 10 === 0) {
                updatePawn();
            }
        }

        function updatePawn() {
            if (!pawn) return;

            if (pawn.state === 'idle') {
                findTask(pawn);
            }
            if (pawn.state === 'moving') {
                movePawn(pawn);
            }
            if (pawn.state === 'working') {
                workOnTask(pawn);
            }
        }

        function findTask(pawn) {
            // IA agora encontra a tarefa MAIS PRÓXIMA
            if (tasks.length === 0) return;

            let closestTask = null;
            let minDistance = Infinity;
            let taskIndex = -1;

            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                // Calcula a distância de Manhattan
                const distance = Math.abs(pawn.x - task.x) + Math.abs(pawn.y - task.y);

                if (distance < minDistance) {
                    minDistance = distance;
                    closestTask = task;
                    taskIndex = i;
                }
            }

            if (closestTask) {
                pawn.task = tasks.splice(taskIndex, 1)[0]; // Atribui e remove da fila
                pawn.state = 'moving';
            }
        }

        function movePawn(pawn) {
            // Pathfinding muito simples (sem evitar obstáculos)
            const targetX = pawn.task.x;
            const targetY = pawn.task.y;

            if (pawn.task.type === 'move') {
                // Lógica para tarefa de MOVIMENTO (parar NO tile)
                if (pawn.x === targetX && pawn.y === targetY) {
                    // Chegou ao destino
                    pawn.task = null;
                    pawn.state = 'idle';
                    return;
                }
            } else {
                // Lógica para tarefas de TRABALHO (parar ADJACENTE)
                const dx = Math.abs(pawn.x - targetX);
                const dy = Math.abs(pawn.y - targetY);

                // Está adjacente (distância de Manhattan de 1)?
                if (dx + dy <= 1) {
                    pawn.state = 'working';
                    pawn.workProgress = 0;
                    return;
                }
            }

            // Move-se em direção ao alvo
            if (pawn.x < targetX) pawn.x++;
            else if (pawn.x > targetX) pawn.x--;
            else if (pawn.y < targetY) pawn.y++;
            else if (pawn.y > targetY) pawn.y--;
        }

        function workOnTask(pawn) {
            pawn.workProgress++;
            if (pawn.workProgress >= 100) { // 100 ticks = ~1.6s
                completeTask(pawn);
            }
        }

        function completeTask(pawn) {
            const task = pawn.task;
            const tile = map[task.y][task.x];

            if (task.type === 'cut' && tile.id === TILE_TYPES.TREE.id) {
                tile.id = TILE_TYPES.GRASS.id;
                tile.color = TILE_TYPES.GRASS.color;
                resources.wood += 10;
            }
            else if (task.type === 'mine' && tile.id === TILE_TYPES.ROCK.id) {
                tile.id = TILE_TYPES.GRASS.id;
                tile.color = TILE_TYPES.GRASS.color;
                resources.stone += 10;
            }
            else if (task.type === 'wall' && tile.id === TILE_TYPES.GRASS.id) {
                if (resources.wood >= 5) {
                    resources.wood -= 5;
                    tile.id = TILE_TYPES.WALL.id;
                    tile.color = TILE_TYPES.WALL.color;
                } else {
                    // Falha ao construir, coloca a tarefa de volta na fila
                    tasks.unshift(pawn.task);
                }
            }

            // Limpa o estado do peão
            pawn.task = null;
            pawn.state = 'idle';
            pawn.workProgress = 0;
        }

        // --- Manipuladores de Eventos ---
        function setupEventListeners() {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                mouseTileX = Math.floor(mouseX / TILE_SIZE);
                mouseTileY = Math.floor(mouseY / TILE_SIZE);
            });

            canvas.addEventListener('click', () => {
                if (!selectedTool) return;

                const x = mouseTileX;
                const y = mouseTileY;

                // Não adiciona se já houver tarefa lá
                if (tasks.some(t => t.x === x && t.y === y)) return;
                // Não adiciona se o peão já estiver trabalhando lá
                if (pawn && pawn.task && pawn.task.x === x && pawn.task.y === y) return;

                const tile = map[y][x];

                if (selectedTool === 'cut' && tile.id === TILE_TYPES.TREE.id) {
                    tasks.push(new Task('cut', x, y));
                }
                else if (selectedTool === 'mine' && tile.id === TILE_TYPES.ROCK.id) {
                    tasks.push(new Task('mine', x, y));
                }
                else if (selectedTool === 'wall' && tile.id === TILE_TYPES.GRASS.id) {
                    tasks.push(new Task('wall', x, y));
                }
                else if (selectedTool === 'move' && tile.id === TILE_TYPES.GRASS.id) {
                    tasks.push(new Task('move', x, y));
                }
            });

            document.getElementById('btn-cut').addEventListener('click', () => {
                selectedTool = (selectedTool === 'cut') ? null : 'cut';
            });
            document.getElementById('btn-mine').addEventListener('click', () => {
                selectedTool = (selectedTool === 'mine') ? null : 'mine';
            });
            document.getElementById('btn-wall').addEventListener('click', () => {
                selectedTool = (selectedTool === 'wall') ? null : 'wall';
            });
            document.getElementById('btn-move').addEventListener('click', () => {
                selectedTool = (selectedTool === 'move') ? null : 'move';
            });
        }

        // --- Loop Principal do Jogo ---
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Iniciar o Jogo ---
        console.log("Iniciando simulação de colônia...");
        initializeMap();
        initializePawn();
        setupEventListeners();
        gameLoop();

    </script>
</body>
</html>
